// from https://cp-algorithms.com/geometry/segments-intersection.html

import kotlin.math.*
import kotlin.random.Random
import java.io.*
import java.lang.StringBuilder
import java.util.*

//// ================================================================= UTIL
const val EPS = 1e-6

fun onSegment(p: Vector2, q: Vector2, r: Vector2) =
    min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&
    min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y)

fun orientation(p: Vector2, q: Vector2, r: Vector2): Int {
    val prod = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
    if (abs(prod) < EPS) return 0
    return if (prod > 0) 1 else 2
}

// returns distance along surface from the landing site
fun collides(a1: Vector2, a2: Vector2, b1: Vector2, b2: Vector2): Boolean {
    val o1 = orientation(a1, a2, b1)
    val o2 = orientation(a1, a2, b2)
    val o3 = orientation(b1, b2, a1)
    val o4 = orientation(b1, b2, a2)

    // General case

    // General case
    if (o1 != o2 && o3 != o4) return true

    // Special Cases

    // Special Cases
    if (o1 == 0 && onSegment(a1, b1, a2)) return true
    if (o2 == 0 && onSegment(a1, b2, a2)) return true
    if (o3 == 0 && onSegment(b1, a1, b2)) return true
    return o4 == 0 && onSegment(b1, a2, b2)
}


data class Vector2(val x: Double, val y: Double) {
    constructor(x: Int, y: Int) : this(x.toDouble(), y.toDouble())

    operator fun unaryMinus(): Vector2 = Vector2(-x, -y)
    operator fun plus(other: Vector2): Vector2 = Vector2(x + other.x, y + other.y)
    operator fun minus(other: Vector2): Vector2 = Vector2(x - other.x, y - other.y)
    operator fun times(scalar: Double): Vector2 = Vector2(x * scalar, y * scalar)
    operator fun div(scalar: Double): Vector2 = Vector2(x / scalar, y / scalar)
    operator fun Double.times(other: Vector2): Vector2 = other * this

    fun norm2(): Double = (x * x + y * y)
    fun norm(): Double = sqrt(norm2())
    override fun toString(): String = "$x $y"
}

fun distance(p: Vector2, q: Vector2) = sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y))

infix fun Double.almostEquals(other: Double) = abs(this - other) < EPS

data class Action(val rotation: Int, val thrust: Int) {
    override fun toString(): String = "$rotation $thrust"
}

fun lerp(a: Double, b: Double, fraction: Double): Double = a + (b - a) * fraction
fun lerp(a: Int, b: Int, fraction: Double): Int = lerp(a.toDouble(), b.toDouble(), fraction).toInt()
fun lerp(a: Vector2, b: Vector2, fraction: Double): Vector2 =
    Vector2(lerp(a.x, b.x, fraction), lerp(a.y, b.y, fraction))

fun lerp(a: Action, b: Action, fraction: Double): Action =
    Action(lerp(a.rotation, b.rotation, fraction), lerp(a.thrust, b.thrust, fraction))






fun clamp(start: Int, end: Int, value: Int) = max(start, min(value, end))
fun clamp(start: Double, end: Double, value: Double) = max(start, min(value, end))

fun Int.toRadian() = this * PI / 180.0
//// =========================================================== SURFACE

class Surface(val terrain: List<Vector2>){
    /** center of landing site along the surface */
    val flatMilestone: Double

    /** 2x extents is flat zone width */
    val flatExtents: Double

    /** length along surface */
    val surfaceLength: Double

    init {
        var s = 0.0
        var milestone = 0.0
        var extent = 0.0
        terrain.zipWithNext().forEach { (p1, p2) ->
            if (p1.y almostEquals p2.y) { // found flat segment
                extent = distance(p1, p2) / 2 // middle of flat zone
                milestone = s + extent
            }
            s += distance(p1, p2)
        }
        flatMilestone = milestone
        flatExtents = extent
        surfaceLength = s
    }
}


//// ========================================================= FITS

fun LanderController.score1(params: LanderParams): Double {
    val vel = params.velocity
    val flatMile = max(surface.surfaceLength - surface.flatMilestone, surface.flatMilestone)

    // score caluclation
    return when {
        params.distanceFromFlat > surface.flatExtents -> // outside landing zone
            lerp(90.0, 0.0, params.distanceFromFlat / surface.surfaceLength)
        params.distanceFromFlat > surface.flatExtents * 0.5 -> // in margin of landing zone
            lerp(100.0, 90.0, params.distanceFromFlat / surface.flatExtents)
        else -> { // take velocity into consideration
            // speed on boundary is factor = 1.0, speed 0 is factor 0. Metric is infinity (box)
            val vFactor = max(abs(params.velocity.x)/20.0, abs(params.velocity.y)/40.0)
            100.0 + when {
                vFactor > 1.0 -> lerp(90.0, 0.0, vFactor/10.0 + 0.1) // >100% terminal speed - 90--0
                vFactor > 0.95 -> lerp(100.0, 90.0, vFactor ) // 95%-100% of terminal speed - 100--90
                else -> {
                    100.0 + (if(params.yaw == 0) 50.0 else 0.0) + 10*params.fuel/initialParams.fuel
                }
            }
        }
    }
}

//// ============================================================== EVOLUTION


typealias Gene = Action
typealias Chromosome = List<Gene>
typealias Population = List<Chromosome>
typealias Ranking = List<Rank>
typealias PopulationEvolver = (Ranking) -> Population
typealias FitnessFunction = LanderController.(params: LanderParams) -> Double

data class Rank(val chromosome: Chromosome, val params: LanderParams, val fitness: Double)

val Ranking.population: Population get() = map { it.chromosome }

// ----------------------------------------------- evolution extensions on primitive data types ------------------------
// mutates gene completely and randomly
fun Gene.randomMutation() = Random.nextGene()

fun Random.nextGene(): Gene = Action(Random.nextInt(-90, 90 + 1), Random.nextInt(0, 4 + 1))
fun Random.nextMarkovGene(gene: Action, rotationSpread: Int = 5): Gene = Action(
    clamp(-90, 90, gene.rotation + Random.nextInt(-rotationSpread, 1+rotationSpread)),
    clamp(0, 4, gene.thrust + Random.nextInt(-1, 1+1))
)

fun Random.nextChromosome(length: Int): Chromosome = List(length) { Random.nextGene() }
fun Random.nextMarkovChromosome(length: Int): Chromosome {
    val ch = mutableListOf(Random.nextGene())
    repeat(length - 1) { ch.add(Random.nextMarkovGene(ch.last())) }
    return ch
}

fun Random.nextPopulation(populationSize: Int, chromosomeLength: Int) =
    List(populationSize) { Random.nextChromosome(chromosomeLength) }

fun Random.nextMarkovPopulation(populationSize: Int, chromosomeLength: Int) =
    List(populationSize) { Random.nextMarkovChromosome(chromosomeLength) }

/** randomly mutate single gene with probability */
fun Gene.mutate(probability: Double = 0.05) = if (Random.nextDouble() <= probability) Random.nextGene() else this.copy()

fun Chromosome.copy() = this.map { it.copy() }

// averages neighboring genes - returns first + averaged pairwise from second FIXME watch out in evolver
fun Chromosome.smoothen() = this.subList(0, 1) + zipWithNext { g1, g2 ->
    Gene(((g1.rotation + g2.rotation) / 2.0).roundToInt(), ((g1.thrust + g2.thrust) / 2.0).roundToInt())
}

// mutates chromosome uniformly - each gene has given chance to mutate
fun Chromosome.uniformMutate(probability: Double = 0.05) =
    this.map { gene -> if (Random.nextDouble() <= probability) Random.nextGene() else gene.copy() }

// one crossover point
infix fun Chromosome.singleCrossover(other: Chromosome): Pair<Chromosome, Chromosome> {
    assert(this.size == other.size)
    val p1 = Random.nextInt(size)
    return (this.subList(0, p1) + other.subList(p1, size)) to
            (other.subList(0, p1) + this.subList(p1, size))
}

// two crossover points
infix fun Chromosome.doubleCrossover(other: Chromosome): Pair<Chromosome, Chromosome> {
    assert(this.size == other.size)
    val (a, b) = (Random.nextInt(size) to Random.nextInt(size))
    val (p1, p2) = (min(a, b) to max(a, b))
    return (this.subList(0, p1) + other.subList(p1, p2) + this.subList(p2, size)) to
            (other.subList(0, p1) + this.subList(p1, p2) + other.subList(p2, size))
}

fun uniformCrossover(ch1: Chromosome, ch2: Chromosome, probability: Double = 0.5): Pair<Chromosome, Chromosome> {
    assert(ch1.size == ch2.size)
    return ch1.zip(ch2).fold(
        listOf<Gene>() to listOf<Gene>(),
        { (c1, c2), (g1, g2) ->
            if (Random.nextDouble() <= probability)
                (c1 + g2) to (c2 + g1) // mutate - by random swap swap
            else
                (c1 + g1) to (c2 + g2)// don't mutate
        })
}

fun lerpCrossover(ch1: Chromosome, ch2: Chromosome, probability: Double = 0.05): Pair<Chromosome, Chromosome> {
    assert(ch1.size == ch2.size)
    val lerpFraction = Random.nextDouble()
    return ch1.zip(ch2).fold(
        listOf<Gene>() to listOf<Gene>(),
        { (c1, c2), (g1, g2) ->
            if (Random.nextDouble() <= probability) { // mutate by lerping continuously on params
                (c1 + lerp(g1, g2, lerpFraction)) to (c2 + lerp(g1, g2, 1.0 - lerpFraction))
            } else { // don't mutate
                (c1 + g1) to (c2 + g2)
            }
        })
}

// ------------------------------------------------------- SOLVER ------------------------------------------------------

/** solver using rolling horizon tactic.
 * @param evolve    Function evolving the population. Returns sorted chromosomes with fitness.
 *                  if population passed to evolver is empty, then it should create starting population
 */
fun LanderController.rollingHorizonSolver(
    evolve: PopulationEvolver,
    fitness: FitnessFunction,
    visualizationInterval: Int = 50, // will visualize after this many populations
    evolverRounds: Int = -995 // will evolve this much rounds for a single step. Negative for miliseconds
) {
    var horizon = 0
    var ranking: Ranking = emptyList()
    var rollingChromosome: Chromosome = emptyList() // resulting chromosome aka series of taken actions
    var populationNr = 0 // ordinal of current popsulation

//    var previousBest: Rank = Rank(emptyList(), LanderParams(), Double.POSITIVE_INFINITY)

    while (true) {
        val solverStart = System.currentTimeMillis() // when solver started
        var evolves = 0 // if evolverRounds is > 0 then at most that many evolves would roll
        // evolve population as much as possible in given timeframe
        while (evolves < evolverRounds || evolverRounds < 0 && System.currentTimeMillis() - solverStart < -evolverRounds) { // FIXME: fit as much based on extrapolated time
            ++evolves

            // evolve population, rank create ranking using
            ranking = evolve(ranking).map {
                val params = simulate(it)
                val fit = fitness(params)
                Rank(it, params, fit)
            }.sortedByDescending { it.fitness }
            // // visualize every nth population
            // if (populationNr % visualizationInterval == 0) {
            //     io.visualization.bestTrajectory = ranking[0].params.path
            //     io.visualization.trajectories = ranking.subList(1, ranking.size).map { it.params.path }
            //     io.visualization.populationNumber = populationNr
            //     io.visualization.repaint()
            // }

            ++populationNr
        }

//        ranking.subList(1, ranking.size)
//            .forEach { io.drawPath(it.second.path, Color.GREEN)/*image.addPath(it.second.path, "1", "lime")*/ }
//        io.drawPath(ranking[0].second.path, Color.RED)        //image.addPath(ranking[0].second.path, "1", "red")
//        image.renderPicture(populationNr)
//        newImage()

        val best = ranking[0]
        io.error("best: ${best.fitness}\n${best.params.pretty()}")

//        if(best.fitness > previousBest.fitness){
//            io.println(fitness(landerParams.deepCopy().simulateUntilCollision(previousBest.chromosome.subList(1, previousBest.chromosome.size))))
//        } else {
//            previousBest = Rank(best.chromosome.copy(), best.params.deepCopy(), best.fitness)
//        }

        // io.error("BEST: ${ranking[0].third}\n${ranking[0].second}")

        ++horizon

        io.println("${best.chromosome[0]}") // output best action from chromosome
        rollingChromosome = rollingChromosome + best.chromosome[0] // append new gene to rolling chromosome

        landerParams = io.nextParams()
        io.error("OK? ${landerParams.landingSucceeded()}")

        // advance to next gene
        ranking = ranking.map {
            Rank(
                it.chromosome.subList(1, it.chromosome.size),
                it.params,
                it.fitness
            )
        }
    }
}

fun rouletteEvolver(
    populationSize: Int,
    eliteSize: Int = 6,
    mutationProbability: Double = 0.05,
    chromosomeLength: Int = 200
): PopulationEvolver =
    { _ranking ->
        if (_ranking.isEmpty()) {
            Random.nextMarkovPopulation(populationSize, chromosomeLength) // .map { it.smoothen() }
        } else {
            val ranking = if (_ranking.size > populationSize) _ranking.subList(0, populationSize) else _ranking

            // elitism
            val children = ranking.subList(0, eliteSize).population.toMutableList()
            val sum = ranking.fold(0.0, { s, rank -> s + rank.fitness }) // for normalization
            // cumulative part in reward
            val cumulative = ranking.runningFold(1.0) { acc, rank -> acc - rank.fitness / sum }

            // crossover
            while (children.size < populationSize) {
                val (r1, r2) = Random.nextDouble() to Random.nextDouble()
                // parents
                val p1 = ranking[cumulative.indexOfLast { it > r1 }]
                val p2 = ranking[cumulative.indexOfLast { it > r2 }]
                // children
                var (c1, c2) = lerpCrossover(p1.chromosome, p2.chromosome)

                children += c1.uniformMutate().smoothen()
                children += c2.uniformMutate().smoothen()
            }

            children
        }
    }

//// ============================================== LANDER CONTROLLER


typealias Path2D = List<Vector2>

// represents parameters of the simulation in a given step
class LanderParams(
    var path: Path2D = listOf(), // path so far
    var distanceFromFlat: Double = 0.0, //
    var position: Vector2 = Vector2(0, 0), // position of the aircraft
    var velocity: Vector2 = Vector2(0, 0), // velocity of the aircraft
    var fuel: Int = 0, // fuel left
    var yaw: Int = 0, // current yaw
    var power: Int = 0 // current power of thrusters
) {
    // copy doesn't preserve path on purpose
    fun deepCopy(): LanderParams =
        LanderParams(
            path = listOf(position.copy()),
            distanceFromFlat = distanceFromFlat,
            position = position.copy(),
            velocity = velocity.copy(),
            fuel = fuel,
            yaw = yaw,
            power = power
        )

    fun pretty(): String {
        return """
            |   Pos=(%.0f %.0f) Vel=(%.2f %.2f) Yaw=%d
            |   Fuel=%d Power=%d Distance=%.0f
            """.trimMargin().format(position.x, position.y, velocity.x, velocity.y, yaw, fuel, power, distanceFromFlat)
    }
}

class LanderController(
    val io: IO,
    val surface: Surface,
    var landerParams: LanderParams
) {


    val initialParams: LanderParams
    private val G = 3.711 // gravitational force
    private val ANGULAR_SPEED = 15 // 15 degrees per second

    private fun Int.toRadian() = this * PI / 180.0
    infix fun Double.almostEquals(other: Double) = abs(this - other) < EPS

    init {
        io.error(landerParams.pretty())
        initialParams = landerParams.deepCopy()
    }

    fun LanderParams.landingSucceeded() = (
            yaw == 0
            && distanceFromFlat <= surface.flatExtents
            && abs(velocity.y) <= 40.0
            && abs(velocity.x) <= 20)

    /** simulates flight, returns parameters on land contact (1 frame after collision) */
    fun LanderParams.simulateUntilCollision(actions: List<Action>): LanderParams {
        val actionIterator = actions.iterator()
        do {
            val action = actionIterator.next() // unsafe use of iterator to catch errors for too short chromosomes
        } while (!stepAndCheckCollision(action))
        return this
    }

    // https://www.codingame.com/forum/t/mars-lander-puzzle-discussion/32/129
    /** Overwrites params with simulation. Returns true if collided.*/
    fun LanderParams.stepAndCheckCollision(action: Action): Boolean {
        var simTime = 0.0

        // -------- save previous state
        val oldPosition = position.copy()


        // -------- update control params
        power = min(
            fuel,
            when {
                action.thrust < power && power > 0 -> power - 1
                action.thrust > power && power < 4 -> power + 1
                else -> power
            }
        )
        val targetYaw = min(90, max(-90, action.rotation))
        fuel -= power

        // -------- fixed step simulation - 1sec - log path

        // rotate
        yaw = when { // clamp rotation
            targetYaw > yaw -> min(yaw + ANGULAR_SPEED, targetYaw)
            targetYaw < yaw -> max(yaw - ANGULAR_SPEED, targetYaw)
            else -> yaw
        }

        // update position
        val gravityForce = Vector2(0.0, -G)
        val thrustForce = Vector2(-sin(yaw.toRadian()), cos(yaw.toRadian())) * power.toDouble()
        val accel = gravityForce + thrustForce
        velocity += accel
        position += velocity + accel / 2.0

        path = path + position

        // -------- collision check
        // bounds check
        when {
            position.x < 0 -> {
                distanceFromFlat = surface.flatMilestone + position.y
                return true
            }
            position.x > 6999 -> {
                distanceFromFlat = surface.surfaceLength - surface.flatMilestone + position.y
                return true
            }
            position.y > 3000 -> {
                // artificially climb towards walls
                distanceFromFlat = min(surface.flatMilestone + position.y + position.x,
                                       surface.surfaceLength - surface.flatMilestone + position.y + 7000 - position.x)
                return true
            }

            // surface check by walking along
            else -> {
                var milestone = 0.0 // point on surface that was hit (0 is start of surface)
                for ((p1, p2) in surface.terrain.zipWithNext()) {
                    if (collides(oldPosition, position, p1, p2)) {
                        milestone += distance(p1, (oldPosition + position) / 2.0) // center of segment as hitpoint
                        distanceFromFlat = abs(surface.flatMilestone - milestone)
                        return true
                    }
                    milestone += distance(p1, p2) // walk along the surface
                }
                return false
            }
        }

    }

    fun simulate(actions: List<Action>): LanderParams = landerParams.deepCopy().simulateUntilCollision(actions)
}


fun main(args: Array<String>) {

    // initialize IO with map data
    val io = IO()

    // ------- read terrain
    val n = io.nextInt() // the number of points used to draw the surface of Mars.
    val terrain = mutableListOf<Vector2>()
    for (i in 0 until n) {
        val (x, y) = io.nextInt() to io.nextInt()
        terrain.add(Vector2(x, y))
    }
    // ------- read initial params
    val controller = LanderController(io, Surface(terrain), io.nextParams())

    controller.rollingHorizonSolver(
        rouletteEvolver(90, chromosomeLength = 300, eliteSize = 30, mutationProbability = 0.2),
        LanderController::score1,
        visualizationInterval = 100,
        evolverRounds = 1
    )
//    controller.rollingHorizonSolver(muLambdaEvolver(200, 150), LanderController::penalty2)
//    controller.rollingHorizonSolver(nonEvolver(), LanderController::penalty1)
}

//// ================================================ MISSING - RUNNING FOLD

public inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {
    val estimatedSize = if (this is Collection<*>) this.size else 9
    if (estimatedSize == 0) return listOf(initial)
    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }
    var accumulator = initial
    for (element in this) {
        accumulator = operation(accumulator, element)
        result.add(accumulator)
    }
    return result
}

//// =================================================== IO

class IO() {

    private val input = Scanner(System.`in`)

    fun error(s: String) = System.err.println(s)
    fun nextInt() = input.nextInt()
    fun nextParams() = LanderParams(
        position = Vector2(nextInt(), nextInt()),
        velocity = Vector2(nextInt(), nextInt()),
        fuel = nextInt(),
        yaw = nextInt(),
        power = nextInt()
    )
    fun println(s: String) = System.out.println(s)
}